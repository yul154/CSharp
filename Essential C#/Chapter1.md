# Basic

## 关键字
> 编译器根据关键字识别代码的结构与组织方式。由于编译器对这些单词有着严格的解释，所以只能将关键字放在特定位置。如违反规则，编译器会报错。

* C#1.0之后没有引入任何新的保留关键字 ，但在后续版本中，一些构造使用了上下文关键字 ，它们在特定位置才有意义，其他位置则无意义。
* C#方法 是已命名代码块，由一个方法声明（例如`static void Main（）`）引入，后跟一对大括号（{}）
* C#要求Main方法返回void或int，而且要么无参，要么接收一个字符串数组。

## 变量
* 局部变量声明后必须在读取前赋值
* C#允许在同一语句中进行多个赋值操作
* 所有string类型的数据，不管是不是字符串字面值（literal）都是不可变的（不可修改）。不能修改变量最初引用的数据，只能重新赋值，让它指向内存中的新位置
* 在字符串中插入的数据标识了两个索引占位符(`$`)。每个占位符都顺序对应格式字符串之后的实参。
---
# 数据类型

## 基本数值类型

### 1. 整数类型

<img width="618" alt="截屏2023-07-11 16 34 16" src="https://github.com/yul154/CSharp/assets/27160394/223aff55-f1b5-4d3e-84ce-23d6569e7b5d">

* C/C++的short数据类型是short int的缩写。

### 2.浮点类型

### 3. decimal类型
* 和浮点数不同，decimal类型保证范围内的所有十进制数都是精确，所以，对于decimal类型来说，0.1就是0.1，而不是近似值
* decimal的范围较小。所以，从浮点类型转换为decimal类型可能发生溢出错误。此外，decimal的计算速度稍慢（虽然差别不大，完全可以忽略）。


### 4. 字面值
> 字面值 （literal value）表示源代码中的固定值。例如，假定希望用System.Console.WriteLine（）输出整数值42和double值1.618034（黄金分割比例），



## null & void

* null可直接赋给字符串变量，表明变量为“空”，不指向任何位置。
* 只能将null赋给引用类型、指针类型和可空值类型
* 一般不能将null值赋给值类型
* 将null赋给引用类型的变量和根本不赋值是不一样的概念
  * ，赋值了null的变量已设置，而未赋值的变量未设置。
  * 使用未赋值的变量会造成编译时错误


## 数据转换
* 布尔类型bool不会隐式转换成整数，
* 使用`float.Parse（)`将string转换为数值类型
* Parse（）和TryParse（）的关键区别在于，
  * 如转换失败，TryParse（）不会引发异常。string到数值类型的转换是否成功，往往要取决于输入文本的用户。。
  * 用户完全可能输入无法成功解析的数据, 使用TryParse（）而不是Parse（），就可以避免在这种情况下引发异常



* 。C#编译器禁止一个代码块中声明（或作为参数声明）的局部变量在其子代码块中重复声明。总之，一个变量的声明空间是当前代码块，以及它的所有子代码块
* 对于声明局部变量的那个块，局部变量都在作用域中，但声明前引用它属于非法。换言之，此时局部变量合法存在，但使用非法。只有在声明后的位置使用才合法。
* ^符号是异或（Exclusive OR，XOR）操作符。若应用于两个布尔操作数，那么只有在两个操作数中仅有一个为true的前提下，XOR操作符才会返回true，


### 条件操作符（？：）
可用条件操作符取代if-else语句来选择两个值中的一个。条件操作符同时使用一个问号和一个冒号

```
condition ? consequence: alternative
```

### 空合并操作符（？？）
> 如果这个值为空，就使用另一个值”，其形式如下。

```
expression1 ?? expression2;
string fullName = fileName?? "default.txt";
```

### 空条件操作符（？.）
```
（args！=null）？（int？）args.Length：null
```

## 方法
* C#不支持全局方法；一切都必须在一个类型声明中。这正是Main（）方法标记为static的原因——它等价于C++的全局方法和Visual Basic的“共享”方法
* 参数名采用camelCase大小写形式

### 表达式主体方法
> 表达式主体方法不是用大括号定义方法主体，而是用=>操作符
* 该操作符的结果数据类型必须与方法返回类型匹配。

```
static string GetFullName(string firstName, string secondName) => $"{firstName} {secondName}";
```

### using
> “导入”文件，这样在使用时就不需要完全限定。这通过using指令（通常在文件顶部）来实现。
* C#不允许 在 using指令中使用通配符，每个命名空间都必须显式导入
* using指令不仅可以在文件顶部使用，还可以在命名空间声明的顶部使用。
* using指令允许省略命名空间限定符来简化类型名称。而using static指令允许将命名空间和类型名称都省略
* 还可利用using指令为命名空间或类型取一个别名。别名是在using指令起作用的范围内可以使用的替代名称


### 引用参数(ref)
> 两者最明显的区别就是本例在参数数据类型前使用了关键字`ref`，这使参数以传引用方式传递，被调用的方法可用新值更新调用者的变量

* 如果被调用的方法将参数指定为`ref`，调用者调用该方法时提供的实参应该是附加了ref前缀的变量(而不是值)。这样调用者就显式确认了目标方法可对它接收到的任何ref参数进行重新赋值
* 调用者应初始化传引用的局部变量，因为被调用的方法可能直接从ref参数 读取数据而不先对其进行赋值
* 用作ref参数的变量必须在传给方法前赋值，因为被调 用的方法可能直接从变量中读取值
* 以传引用的方式传入一个未初始化的局部变量。为此，代码需要用关键字out修饰参数类型
* 只读传引用造成值类型以传引用的方式传给 方法。不仅不会每次调用方法都创建值类型的拷贝，而且被调用的方 法不能修改值类型
* 数量可变的参数：在方法声明的最后一个参数前添加params关键字，将最后一个参数声明为数组

* 一个类包含两个或多个同名方法，就会发生方法重载。对于重载的方法，参数数量和/或数据类型肯定不同，方法的唯一性取决于方法名、参数数据类型或参数数量的
差异。

### 捕获异常
> try块之后必须紧跟着一个或多个catch块(或/和一个finally 块)。catch块(参见稍后的“高级主题:常规catch”)可指定异常 的数据类型

* 假如一直找不到合适的catch块，抛出的异常就会变成一个未处 理的异常
* catch块 必须从最具体到最不具体排列
* 只要控制离开try块，finally块 就会执行。finally块的作用是提供一个最终位置
* 无论try块是否抛出异常，甚至无论是否写了一个catch块来处理 异常，finally块都会执行
* 抛出异常需要有Exception的实例
* throw语句是“空”的，没有指定 exception变量所引用的异常。区别在于，throw保留了异常中的 “调用栈”信息，而throw exception将那些信息替换成当前调用栈信息。
* 
-----
# 类

